from typing import List, TypeVar, Optional
import random

T = TypeVar('T', int, float, str)

def quick_sort(array: List[T], low: int = 0, high: Optional[int] = None) -> None:
    """
    Усовершенствованная реализация алгоритма быстрой сортировки.
    
    Args:
        array: Сортируемый массив
        low: Начальный индекс (по умолчанию 0)
        high: Конечный индекс (по умолчанию None - вычисляется автоматически)
    """
    if high is None:
        high = len(array) - 1
    
    # Используем итеративный подход для избежания переполнения стека
    while low < high:
        if high - low < 16:  # Оптимизация для маленьких массивов
            insertion_sort(array, low, high)
            break
        
        pi = partition(array, low, high)
        
        # Рекурсивно сортируем меньшую часть, итеративно - большую
        if pi - low < high - pi:
            quick_sort(array, low, pi - 1)
            low = pi + 1
        else:
            quick_sort(array, pi + 1, high)
            high = pi - 1

def partition(array: List[T], low: int, high: int) -> int:
    """
    Улучшенный метод разбиения массива с выбором медианы трех в качестве опорного элемента.
    
    Args:
        array: Массив для разбиения
        low: Начальный индекс
        high: Конечный индекс
    
    Returns:
        Индекс опорного элемента после разбиения
    """
    # Выбор медианы трех для улучшения производительности
    mid = (low + high) // 2
    if array[mid] < array[low]:
        array[low], array[mid] = array[mid], array[low]
    if array[high] < array[low]:
        array[low], array[high] = array[high], array[low]
    if array[high] < array[mid]:
        array[mid], array[high] = array[high], array[mid]
    
    # Опорный элемент - медиана
    pivot = array[mid]
    array[mid], array[high - 1] = array[high - 1], array[mid]
    
    i = low
    j = high - 1
    
    while True:
        i += 1
        while array[i] < pivot:
            i += 1
        j -= 1
        while array[j] > pivot:
            j -= 1
        
        if i >= j:
            break
        
        array[i], array[j] = array[j], array[i]
    
    array[i], array[high - 1] = array[high - 1], array[i]
    return i

def insertion_sort(array: List[T], low: int, high: int) -> None:
    """
    Сортировка вставками для маленьких массивов (оптимизация).
    
    Args:
        array: Массив для сортировки
        low: Начальный индекс
        high: Конечный индекс
    """
    for i in range(low + 1, high + 1):
        key = array[i]
        j = i - 1
        while j >= low and array[j] > key:
            array[j + 1] = array[j]
            j -= 1
        array[j + 1] = key

def quick_sort_simple(array: List[T]) -> List[T]:
    """
    Упрощенная версия быстрой сортировки для удобства использования.
    
    Args:
        array: Массив для сортировки
    
    Returns:
        Отсортированный массив
    """
    if len(array) <= 1:
        return array
    
    pivot = array[len(array) // 2]
    left = [x for x in array if x < pivot]
    middle = [x for x in array if x == pivot]
    right = [x for x in array if x > pivot]
    
    return quick_sort_simple(left) + middle + quick_sort_simple(right)

def print_array(array: List[T], message: str = "") -> None:
    """
    Улучшенный метод для вывода массива.
    
    Args:
        array: Массив для вывода
        message: Сообщение перед выводом массива
    """
    if message:
        print(message)
    print(" ".join(map(str, array)))

def is_sorted(array: List[T]) -> bool:
    """
    Проверка, отсортирован ли массив.
    
    Args:
        array: Массив для проверки
    
    Returns:
        True если массив отсортирован, иначе False
    """
    return all(array[i] <= array[i + 1] for i in range(len(array) - 1))

def benchmark_sort(array: List[T], sort_func: callable, func_name: str) -> None:
    """
    Бенчмарк для тестирования производительности сортировки.
    
    Args:
        array: Массив для сортировки
        sort_func: Функция сортировки
        func_name: Название функции для вывода
    """
    import time
    test_array = array.copy()
    
    start_time = time.time()
    sort_func(test_array)
    end_time = time.time()
    
    print(f"{func_name}: {end_time - start_time:.6f} секунд")
    print(f"Отсортирован корректно: {is_sorted(test_array)}")

if __name__ == "__main__":
    # Тестирование на различных массивах
    test_arrays = {
        "Случайный массив": [10, 7, 8, 9, 1, 5],
        "Уже отсортированный": [1, 2, 3, 4, 5],
        "Обратный порядок": [5, 4, 3, 2, 1],
        "С повторениями": [3, 1, 4, 1, 5, 9, 2, 6, 5],
        "Один элемент": [42],
        "Пустой массив": []
    }
    
    for name, array in test_arrays.items():
        print(f"\n{name}:")
        print_array(array, "Исходный массив:")
        
        if array:  # Не сортируем пустой массив оригинальной функцией
            test_arr = array.copy()
            quick_sort(test_arr)
            print_array(test_arr, "Отсортированный массив (in-place):")
        else:
            print("Пустой массив - сортировка не требуется")
        
        sorted_arr = quick_sort_simple(array)
        print_array(sorted_arr, "Отсортированный массив (функциональный):")
        
        print(f"Проверка сортировки: {is_sorted(sorted_arr)}")
    
    # Бенчмарк производительности
    print("\n" + "="*50)
    print("БЕНЧМАРК ПРОИЗВОДИТЕЛЬНОСТИ")
    print("="*50)
    
    large_array = [random.randint(1, 1000) for _ in range(1000)]
    benchmark_sort(large_array, quick_sort, "Быстрая сортировка (in-place)")
    
    # Для функциональной версии нужно создать копию
    large_array_copy = large_array.copy()
    start_time = time.time()
    result = quick_sort_simple(large_array_copy)
    end_time = time.time()
    print(f"Быстрая сортировка (функциональная): {end_time - start_time:.6f} секунд")
    print(f"Отсортирован корректно: {is_sorted(result)}")
